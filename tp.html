<!DOCTYPE html>
<html>
    <head>
        <style>
            body { 
            }
            canvas {
                width: 800;
                height: 600;
            }
            #render-button {
                width: 180px;
                height: 50px;
                font-size: 24pt;
            }
            #the-canvas { border: 1px solid darkblue; }
            #user-matrix input { width: 64px; font-size: 24px; }
        </style>
    </head>

    <body>
        <canvas id = "the-canvas" width = "800" height = "600"></canvas>
        <script src = "lib.js"></script>
        <script src = "vector.js"></script>
        <script src = "matrix.js"></script>
        <script src = "mesh.js"></script>
        <script src = "controls.js"></script>
        <script src = "cam.js"></script>
        <script src = "material.js"></script>
        <script src = "node.js"></script>
        <script src = "render_mesh.js"></script>
        <script>
            let canvas = document.getElementById( 'the-canvas' );
            /** @type {WebGLRenderingContext} */
            let gl = canvas.getContext( 'webgl2' );
            /*
            const metal_img = new Image();
            const metal_texture = gl.createTexture();
            metal_img.onload = () => {
                gl.activateTexture(gl.TEXTURE0+1);
                gl.bindTexture(gl.TEXTURE_2D, metal_texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, metal_img);
                gl.generateMipmap(gl.TEXTURE_2D);
                gl.active
            }
            metal_img.src = "metal_scale.png";
            */
            
            //create texture
            /*
            let texture = gl.createTexture();
            let image = new Image();
            image.src = '2k_mercury.jpg';
            image.onload = on_load;
            function on_load(){
                //gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.generateMipmap(gl.TEXTURE_2D);
                let loc = gl.getAttribLocation()
            };
            */
            function generate_render_jobs(parent_matrix, node, jobs){ //generate render jobs from slides
                let matrix = parent_matrix.mul(node.get_matrix());
                if (node.data != null) { //slides have this as this.data
                    jobs.push(new RenderMesh(matrix, node.data)); //slides have this as this.data
                }
                for(let child of node.children){
                    generate_render_jobs(matrix, child, jobs);
                }
            }


            let vertex_source = 
            `   #version 300 es
                precision mediump float;

                uniform mat4 modelview;
                uniform mat4 model;
                uniform mat4 view;

                in vec3 coordinates;
                in vec4 color;
                in vec2 uv;
                in vec3 normal;

                out vec4 v_color;
                out vec2 v_uv;

                uniform float mat_ambient;
                uniform float mat_diffuse;
                uniform float mat_specular;
                uniform float mat_shininess;

                uniform vec3 sun_dir; //direction TO the sun
                uniform vec3 sun_color;
                uniform vec3 red_pos;
                uniform vec3 red_color;
                uniform vec3 camera_pos;

                vec3 diff_color(
                        vec3 normal,
                        vec3 light_dir,
                        vec3 light_color,
                        float mat_diffuse
                ){
                    return mat_diffuse * light_color * max(dot(normal, light_dir), 0.0);
                }
                
                void main( void ) {
                    gl_Position = modelview * vec4( coordinates, 1.0 );
                    v_color = color;
                    v_uv = uv;

                    //transform normal
                    vec3 normal_tx = normalize(mat3(model) * normal);

                    //transform coordinates
                    vec3 coords_tx = (model * vec4(coordinates, 1.0)).xyz;

                    //normalized sun_dir
                    vec3 norm_sun_dir = normalize(sun_dir);
                    
                    //direction to point light
                    vec3 to_pt_light = normalize(red_pos - coords_tx);
                    float distance = length(to_pt_light);

                    //attenuation of point light
                    float attenuation = 1.0 / (distance * distance);

                    //set ambient color
                    vec4 ambient_color = vec4(mat_ambient, mat_ambient, mat_ambient, 1.0);

                    //diffuse (sun)
                    vec3 diffuse = diff_color(normal_tx, norm_sun_dir, sun_color, mat_diffuse);
                    //diffuse (red)
                    vec3 red_diffuse = diff_color(normal_tx, to_pt_light, red_color, mat_diffuse) * attenuation;
                    
                    //specular
                    vec3 specular = vec3(0.0);
                    float cos_light_surf_normal = dot(normal_tx, norm_sun_dir);
                    if (cos_light_surf_normal >= 0.0){
                        vec3 R = 2.0 * dot(normal_tx, norm_sun_dir) * normal_tx - norm_sun_dir;
                        vec3 V = normalize(camera_pos - coords_tx);
                        specular = mat_specular * pow(max(dot(R, V), 0.0), mat_shininess) * sun_color;
                    }
                    //specular (red)
                    vec3 red_specular = vec3(0.0);
                    float cos_red_surf_normal = dot(normal_tx, to_pt_light);
                    if (cos_red_surf_normal >= 0.0){
                        vec3 red_R = 2.0 * dot(normal_tx, to_pt_light) * normal_tx - to_pt_light;
                        vec3 V = normalize(camera_pos - coords_tx);
                        red_specular = mat_specular * pow(max(dot(red_R, V), 0.0), mat_shininess) * red_color * attenuation;
                    }
                    
                    //combine lighting components to get final ambient color
                    v_color = ambient_color + vec4(diffuse, 1.0) +  vec4(specular, 1.0) + vec4(red_diffuse, 1.0) + vec4(red_specular, 1.0);
                }
            `;
            
            let fragment_source = 
            `   #version 300 es
                precision mediump float;

                in vec4 v_color;
                in vec2 v_uv;

                uniform sampler2D tex_0;

                out vec4 f_color;

                void main( void ) {
                    // f_color = v_color;
                    f_color = v_color * texture (tex_0, v_uv);
                }
            `;

            let shader_program = 
                create_compile_and_link_program( gl, vertex_source, fragment_source );
            gl.useProgram( shader_program );
            let metal_texture = gl.createTexture();
            let metal_image = new Image();
            metal_image.src = 'metal_scale.png';
            metal_image.onload = on_load_metal;
            function on_load_metal(){
                gl.bindTexture(gl.TEXTURE_2D, metal_texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, metal_image);
                gl.generateMipmap(gl.TEXTURE_2D);
            };
            let dirt_texture = gl.createTexture();
            let dirt_image = new Image();
            dirt_image.src = 'minecraft_dirt.png';
            dirt_image.onload = on_load_dirt;
            function on_load_dirt(){
                gl.bindTexture(gl.TEXTURE_2D, dirt_texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, dirt_image);
                gl.generateMipmap(gl.TEXTURE_2D);
            };
            set_render_params( gl );

            let cow = Mesh.from_obj_file(gl, "cow.obj", shader_program, "metal_scale.png", () => {
                console.log("done");
            });
            let last_update = performance.now();
            const DESIRED_TICK_RATE = 60;
            const DESIRED_MSPT = 1000.0 / DESIRED_TICK_RATE;

            const ROTATION_SPEED = 0.125; // eighth turn per second
            const ROTATION_SPEED_PER_FRAME = ROTATION_SPEED / DESIRED_TICK_RATE;

            const FLY_SPEED = 1;    // units per second
            const FLY_SPEED_PER_FRAME = FLY_SPEED / DESIRED_TICK_RATE;

            let keys = Keys.start_listening();
            let cam = new Camera();
            cam.translate( 0, 0, -1.5);
            const camera_pos = {x: cam.x, y:cam.y, z: cam.z};

            set_uniform_vec3(gl, shader_program, 'sun_dir', 1.0, 0.0, 0.0);
            set_uniform_vec3(gl, shader_program, 'sun_color', 1.0, 1.0, 1.0);
            set_uniform_vec3(gl, shader_program, 'red_pos', -1.0, -1.0, 0.0);
            set_uniform_vec3(gl, shader_program, 'red_color', 1.0, 0.0, 0.0);


            //trying to create a second sphere that is the child of the first sphere here
            const metal_material = new Material(0.25, 1.0, 2.0, 4, metal_texture);
            //const metal_material = new Material(0.25, 1.0, 2.0, 4, texture);
            const dirt_material = new Material(0.25, 1.0, 1.0, 1, dirt_texture);
            let rootSphere = Mesh.make_uv_sphere( gl, shader_program, 20, metal_material);
            let projection = Mat4.perspective_fovx( 0.25, 4 / 3, 0.25, 64 );

            let rootNode = new Node();
            let childNode = rootNode.add_child();
            childNode.data = cow;
            childNode.position = new Vec4(0,0,0,1);
            childNode.pitch = 0.25;
            childNode.yaw = 0.1;

            let secondSphere = Mesh.box(gl, shader_program, 1,1,1, dirt_material);
            let secondChildNode = childNode.add_child();
            secondChildNode.data = secondSphere;
            secondChildNode.position = new Vec4(-1,0,0,1);


            function render( now ) {
                let dt = (now - last_update) / 1000;

                gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
                let jobs = []; //render jobs
                set_uniform_vec3(gl, shader_program, 'camera_pos', cam.x, cam.y, cam.z); //update camera pos every render
                set_uniform_matrix4(gl, shader_program, 'view', projection.data); //view matrix
                generate_render_jobs(new Mat4(), rootNode, jobs);
                for (let job of jobs){
                    let model = job.matrix;
                    set_uniform_matrix4(gl, shader_program, 'model', model.data); //model in this case is just the identity matrix
                    model = cam.get_view_matrix().mul(model);
                    model = projection.mul(model);
                    set_uniform_matrix4(gl, shader_program, "modelview", model.data ); //modelview is view (projection) multiplied with the model
                    job.mesh.render(gl); //custom render function in mesh.js
                }

                requestAnimationFrame( render );
            }

            const KEYMAP = {
                'KeyW': function() { cam.move_in_direction( 0, 0, FLY_SPEED_PER_FRAME ); },
                'KeyS': function() { cam.move_in_direction( 0, 0, -FLY_SPEED_PER_FRAME ); },
                'KeyA': function() { cam.move_in_direction( -FLY_SPEED_PER_FRAME, 0, 0 ); },
                'KeyD': function() { cam.move_in_direction( FLY_SPEED_PER_FRAME, 0, 0 ); },
                'Space': function() { cam.translate( 0, FLY_SPEED_PER_FRAME, 0 ); },
                'KeyC': function() { cam.translate( 0, -FLY_SPEED_PER_FRAME, 0 ); },
                'KeyQ': function() { cam.add_roll( -ROTATION_SPEED_PER_FRAME ); },
                'KeyE': function() { cam.add_roll( ROTATION_SPEED_PER_FRAME ); },
                'ArrowLeft': function() { cam.add_yaw( -ROTATION_SPEED_PER_FRAME ); },
                'ArrowRight': function() { cam.add_yaw( ROTATION_SPEED_PER_FRAME ); },
                'ArrowUp': function() { cam.add_pitch( -ROTATION_SPEED_PER_FRAME ); },
                'ArrowDown': function() { cam.add_pitch( ROTATION_SPEED_PER_FRAME ); },
            };

            function update() {
                let keys_down = keys.keys_down_list();
                const camera_pos = {x: cam.x, y:cam.y, z:cam.z}; //update camera_pos

                for( const key of keys_down ) {
                   let bound_function = KEYMAP[ key ];

                   if( bound_function ) {
                       bound_function();
                   }
                }

                return;
            }
            
            requestAnimationFrame( render );
            setInterval( update, DESIRED_MSPT );
        </script>
    </body>
</html>